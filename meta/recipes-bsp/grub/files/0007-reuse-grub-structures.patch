From ac166eb5544c51f93bbd17ee0a748af67c65809f Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Thu, 19 Mar 2015 13:54:37 -0700
Subject: [PATCH 07/16] reuse grub structures

---
 grub-core/loader/efi/chainloader.c | 363 +++++++++++--------------------------
 1 file changed, 104 insertions(+), 259 deletions(-)

diff --git a/grub-core/loader/efi/chainloader.c b/grub-core/loader/efi/chainloader.c
index 4d26b43..f3877fd 100644
--- a/grub-core/loader/efi/chainloader.c
+++ b/grub-core/loader/efi/chainloader.c
@@ -32,6 +32,7 @@
 #include <grub/efi/api.h>
 #include <grub/efi/efi.h>
 #include <grub/efi/disk.h>
+#include <grub/efi/pe32.h>
 #include <grub/command.h>
 #include <grub/i18n.h>
 #include <grub/net.h>
@@ -53,175 +54,33 @@ static grub_efi_char16_t *cmdline;
 
 
 //
-// PE32+ Machine type for EFI images
+// Additional PE32+ Machine type for EFI images
 //
-#define IMAGE_FILE_MACHINE_I386            0x014c
-#define IMAGE_FILE_MACHINE_IA64            0x0200
 #define IMAGE_FILE_MACHINE_EBC             0x0EBC
-#define IMAGE_FILE_MACHINE_X64             0x8664
 #define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED  0x01c2
 #define IMAGE_FILE_MACHINE_ARM64	   0xaa64
 
-
-///
-/// Length of ShortName.
-///
-#define EFI_IMAGE_SIZEOF_SHORT_NAME 8
-
-#define EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES 16
+#define SIGNATURE_16(A, B)        ((A) | (B << 8))
+#define SIGNATURE_32(A, B, C, D)  (SIGNATURE_16 (A, B) | (SIGNATURE_16 (C, D) << 16))
 
 #define EFI_IMAGE_DOS_SIGNATURE     SIGNATURE_16('M', 'Z')
 #define EFI_IMAGE_NT_SIGNATURE      SIGNATURE_32('P', 'E', '\0', '\0')
 
-//
-// Characteristics
-//
-#define EFI_IMAGE_FILE_RELOCS_STRIPPED      (1 << 0)     ///< 0x0001  Relocation info stripped from file.
-#define EFI_IMAGE_FILE_EXECUTABLE_IMAGE     (1 << 1)     ///< 0x0002  File is executable  (i.e. no unresolved externel references).
-#define EFI_IMAGE_FILE_LINE_NUMS_STRIPPED   (1 << 2)     ///< 0x0004  Line nunbers stripped from file.
-#define EFI_IMAGE_FILE_LOCAL_SYMS_STRIPPED  (1 << 3)     ///< 0x0008  Local symbols stripped from file.
-#define EFI_IMAGE_FILE_BYTES_REVERSED_LO    (1 << 7)     ///< 0x0080  Bytes of machine word are reversed.
-#define EFI_IMAGE_FILE_32BIT_MACHINE        (1 << 8)     ///< 0x0100  32 bit word machine.
-#define EFI_IMAGE_FILE_DEBUG_STRIPPED       (1 << 9)     ///< 0x0200  Debugging info stripped from file in .DBG file.
-#define EFI_IMAGE_FILE_SYSTEM               (1 << 12)    ///< 0x1000  System File.
-#define EFI_IMAGE_FILE_DLL                  (1 << 13)    ///< 0x2000  File is a DLL.
-#define EFI_IMAGE_FILE_BYTES_REVERSED_HI    (1 << 15)    ///< 0x8000  Bytes of machine word are reversed.
-
-//
-// Directory Entries
-//
-#define EFI_IMAGE_DIRECTORY_ENTRY_EXPORT      0
-#define EFI_IMAGE_DIRECTORY_ENTRY_IMPORT      1
-#define EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE    2
-#define EFI_IMAGE_DIRECTORY_ENTRY_EXCEPTION   3
-#define EFI_IMAGE_DIRECTORY_ENTRY_SECURITY    4
-#define EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC   5
-#define EFI_IMAGE_DIRECTORY_ENTRY_DEBUG       6
-#define EFI_IMAGE_DIRECTORY_ENTRY_COPYRIGHT   7
-#define EFI_IMAGE_DIRECTORY_ENTRY_GLOBALPTR   8
-#define EFI_IMAGE_DIRECTORY_ENTRY_TLS         9
-#define EFI_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
-
-#define EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES 16
-///
-/// @attention
-/// EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC means PE32+ and 
-/// EFI_IMAGE_OPTIONAL_HEADER64 must be used. The data structures only vary
-/// after NT additional fields.
-///
-#define EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
-///
-/// @attention
-/// EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC means PE32 and 
-/// EFI_IMAGE_OPTIONAL_HEADER32 must be used. The data structures only vary
-/// after NT additional fields.
-///
-#define EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b
-///
-/// COFF File Header (Object and Image).
-///
-typedef struct {
-  grub_efi_uint16_t  Machine;
-  grub_efi_uint16_t  NumberOfSections;
-  grub_efi_uint32_t  TimeDateStamp;
-  grub_efi_uint32_t  PointerToSymbolTable;
-  grub_efi_uint32_t  NumberOfSymbols;
-  grub_efi_uint16_t  SizeOfOptionalHeader;
-  grub_efi_uint16_t  Characteristics;
-} EFI_IMAGE_FILE_HEADER;
-
-///
-/// Header Data Directories.
-///
-typedef struct {
-  grub_efi_uint32_t  VirtualAddress;
-  grub_efi_uint32_t  Size;
-} EFI_IMAGE_DATA_DIRECTORY;
-
-///
-/// Optional Header Standard Fields for PE32.
-///
-typedef struct {
-  ///
-  /// Standard fields.
-  ///
-  grub_efi_uint16_t                    Magic;
-  grub_efi_uint8_t                     MajorLinkerVersion;
-  grub_efi_uint8_t                     MinorLinkerVersion;
-  grub_efi_uint32_t                    SizeOfCode;
-  grub_efi_uint32_t                    SizeOfInitializedData;
-  grub_efi_uint32_t                    SizeOfUninitializedData;
-  grub_efi_uint32_t                    AddressOfEntryPoint;
-  grub_efi_uint32_t                    BaseOfCode;
-  grub_efi_uint32_t                    BaseOfData;  ///< PE32 contains this additional field, which is absent in PE32+.
-  ///
-  /// Optional Header Windows-Specific Fields.
-  ///
-  grub_efi_uint32_t                    ImageBase;
-  grub_efi_uint32_t                    SectionAlignment;
-  grub_efi_uint32_t                    FileAlignment;
-  grub_efi_uint16_t                    MajorOperatingSystemVersion;
-  grub_efi_uint16_t                    MinorOperatingSystemVersion;
-  grub_efi_uint16_t                    MajorImageVersion;
-  grub_efi_uint16_t                    MinorImageVersion;
-  grub_efi_uint16_t                    MajorSubsystemVersion;
-  grub_efi_uint16_t                    MinorSubsystemVersion;
-  grub_efi_uint32_t                    Win32VersionValue;
-  grub_efi_uint32_t                    SizeOfImage;
-  grub_efi_uint32_t                    SizeOfHeaders;
-  grub_efi_uint32_t                    CheckSum;
-  grub_efi_uint16_t                    Subsystem;
-  grub_efi_uint16_t                    DllCharacteristics;
-  grub_efi_uint32_t                    SizeOfStackReserve;
-  grub_efi_uint32_t                    SizeOfStackCommit;
-  grub_efi_uint32_t                    SizeOfHeapReserve;
-  grub_efi_uint32_t                    SizeOfHeapCommit;
-  grub_efi_uint32_t                    LoaderFlags;
-  grub_efi_uint32_t                    NumberOfRvaAndSizes;
-  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
-} EFI_IMAGE_OPTIONAL_HEADER32;
+static const grub_efi_uint16_t machine_type =
+#if defined(__x86_64__)
+	GRUB_PE32_MACHINE_X86_64;
+#elif defined(__aarch64__)
+	IMAGE_FILE_MACHINE_ARM64;
+#elif defined(__arm__)
+	IMAGE_FILE_MACHINE_ARMTHUMB_MIXED;
+#elif defined(__i386__) || defined(__i486__) || defined(__i686__)
+	GRUB_PE32_MACHINE_I386;
+#elif defined(__ia64__)
+	GRUB_PE32_MACHINE_IA64;
+#else
+#error this architecture is not supported by shim
+#endif
 
-///
-/// Optional Header Standard Fields for PE32+.
-///
-typedef struct {
-  ///
-  /// Standard fields.
-  ///
-  grub_efi_uint16_t                    Magic;
-  grub_efi_uint8_t                     MajorLinkerVersion;
-  grub_efi_uint8_t                     MinorLinkerVersion;
-  grub_efi_uint32_t                    SizeOfCode;
-  grub_efi_uint32_t                    SizeOfInitializedData;
-  grub_efi_uint32_t                    SizeOfUninitializedData;
-  grub_efi_uint32_t                    AddressOfEntryPoint;
-  grub_efi_uint32_t                    BaseOfCode;
-  ///
-  /// Optional Header Windows-Specific Fields.
-  ///
-  grub_efi_uint64_t                    ImageBase;
-  grub_efi_uint32_t                    SectionAlignment;
-  grub_efi_uint32_t                    FileAlignment;
-  grub_efi_uint16_t                    MajorOperatingSystemVersion;
-  grub_efi_uint16_t                    MinorOperatingSystemVersion;
-  grub_efi_uint16_t                    MajorImageVersion;
-  grub_efi_uint16_t                    MinorImageVersion;
-  grub_efi_uint16_t                    MajorSubsystemVersion;
-  grub_efi_uint16_t                    MinorSubsystemVersion;
-  grub_efi_uint32_t                    Win32VersionValue;
-  grub_efi_uint32_t                    SizeOfImage;
-  grub_efi_uint32_t                    SizeOfHeaders;
-  grub_efi_uint32_t                    CheckSum;
-  grub_efi_uint16_t                    Subsystem;
-  grub_efi_uint16_t                    DllCharacteristics;
-  grub_efi_uint64_t                    SizeOfStackReserve;
-  grub_efi_uint64_t                    SizeOfStackCommit;
-  grub_efi_uint64_t                    SizeOfHeapReserve;
-  grub_efi_uint64_t                    SizeOfHeapCommit;
-  grub_efi_uint32_t                    LoaderFlags;
-  grub_efi_uint32_t                    NumberOfRvaAndSizes;
-  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
-} EFI_IMAGE_OPTIONAL_HEADER64;
 
 ///
 /// @attention
@@ -229,8 +88,8 @@ typedef struct {
 ///
 typedef struct {
   grub_efi_uint32_t                      Signature;
-  EFI_IMAGE_FILE_HEADER       FileHeader;
-  EFI_IMAGE_OPTIONAL_HEADER32 OptionalHeader;
+  struct grub_pe32_coff_header       FileHeader;
+  struct grub_pe32_optional_header OptionalHeader;
 } EFI_IMAGE_NT_HEADERS32;
 
 ///
@@ -239,8 +98,8 @@ typedef struct {
 ///
 typedef struct {
   grub_efi_uint32_t                      Signature;
-  EFI_IMAGE_FILE_HEADER       FileHeader;
-  EFI_IMAGE_OPTIONAL_HEADER64 OptionalHeader;
+  struct grub_pe32_coff_header       FileHeader;
+  struct grub_pe64_optional_header OptionalHeader;
 } EFI_IMAGE_NT_HEADERS64;
 
 ///
@@ -255,7 +114,7 @@ typedef struct {
   grub_efi_uint32_t                    AddressOfEntryPoint;  ///< Offset to entry point -- from original optional header.
   grub_efi_uint32_t                    BaseOfCode;           ///< From original image -- required for ITP debug.
   grub_efi_uint64_t                    ImageBase;            ///< From original file header.
-  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[2];     ///< Only base relocation and debug directory.
+  struct grub_pe32_data_directory  DataDirectory[2];     ///< Only base relocation and debug directory.
 } EFI_TE_IMAGE_HEADER;
 
 ///
@@ -293,40 +152,22 @@ typedef union {
   EFI_TE_IMAGE_HEADER      Te;
 } EFI_IMAGE_OPTIONAL_HEADER_UNION;
 
-///
-/// Section Table. This table immediately follows the optional header.
-///
-typedef struct {
-  grub_efi_uint8_t Name[EFI_IMAGE_SIZEOF_SHORT_NAME];
-  union {
-    grub_efi_uint32_t  PhysicalAddress;
-    grub_efi_uint32_t  VirtualSize;
-  } Misc;
-  grub_efi_uint32_t  VirtualAddress;
-  grub_efi_uint32_t  SizeOfRawData;
-  grub_efi_uint32_t  PointerToRawData;
-  grub_efi_uint32_t  PointerToRelocations;
-  grub_efi_uint32_t  PointerToLinenumbers;
-  grub_efi_uint16_t  NumberOfRelocations;
-  grub_efi_uint16_t  NumberOfLinenumbers;
-  grub_efi_uint32_t  Characteristics;
-} EFI_IMAGE_SECTION_HEADER;
 
-typedef struct {
+struct grub_shim_pe_coff_loader_image_context {
 	grub_efi_uint64_t ImageAddress;
 	grub_efi_uint64_t ImageSize;
 	grub_efi_uint64_t EntryPoint;
 	grub_efi_uintn_t SizeOfHeaders;
 	grub_efi_uint16_t ImageType;
 	grub_efi_uint16_t NumberOfSections;
-	EFI_IMAGE_SECTION_HEADER *FirstSection;
-	EFI_IMAGE_DATA_DIRECTORY *RelocDir;
-	EFI_IMAGE_DATA_DIRECTORY *SecDir;
+	struct grub_pe32_section_table *FirstSection;
+	struct grub_pe32_data_directory *RelocDir;
+	struct grub_pe32_data_directory *SecDir;
 	grub_efi_uint64_t NumberOfRvaAndSizes;
 	EFI_IMAGE_OPTIONAL_HEADER_UNION *PEHdr;
-} PE_COFF_LOADER_IMAGE_CONTEXT;
+};
 
-struct grub_efi_shim_lock
+struct grub_shim_lock
 {
   grub_efi_status_t
   (*Verify) (void *buffer,
@@ -335,36 +176,26 @@ struct grub_efi_shim_lock
   grub_efi_status_t
   (*Hash) (grub_int8_t *data,
 	   grub_int32_t datasize,
-	   PE_COFF_LOADER_IMAGE_CONTEXT *context,
+	   struct grub_shim_pe_coff_loader_image_context *context,
 	   grub_uint8_t sha256hash,
 	   grub_uint8_t sha1hash);
 
   grub_efi_status_t
   (*Context) (void *data,
 	      grub_uint32_t datasize,
-	      PE_COFF_LOADER_IMAGE_CONTEXT *context);
+	      struct grub_shim_pe_coff_loader_image_context *context);
 };
 
-typedef struct grub_efi_shim_lock grub_efi_shim_lock_t;
-
 static grub_efi_guid_t shim_protocol_guid = GRUB_EFI_SHIM_PROTOCOL_GUID;
 
-/* here's a chart:
- *		i686	x86_64	aarch64
- *  64-on-64:	nyet	yes	yes
- *  64-on-32:	nyet	yes	nyet
- *  32-on-32:	yes	yes	no
- */
 static int
 allow_64_bit(void)
 {
-#if defined(__x86_64__) || defined(__aarch64__)
+/* TODO: what is the definition for aarch64? */
+#if defined(__x86_64__)
 	return 1;
 #elif defined(__i386__) || defined(__i686__)
-	/* Right now blindly assuming the kernel will correctly detect this
-	 * and /halt the system/ if you're not really on a 64-bit cpu */
-	if (in_protocol)
-		return 1;
+/* TODO: find out what to do with in_protocol */
 	return 0;
 #else /* assuming everything else is 32-bit... */
 	return 0;
@@ -375,29 +206,43 @@ static int
 image_is_64_bit(EFI_IMAGE_OPTIONAL_HEADER_UNION *PEHdr)
 {
 	/* .Magic is the same offset in all cases */
-	if (PEHdr->Pe32Plus.OptionalHeader.Magic
-			== EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+	if (PEHdr->Pe32Plus.OptionalHeader.magic
+			== GRUB_PE32_PE64_MAGIC)
 		return 1;
 	return 0;
 }
 
 static int
+allow_32_bit(void)
+{
+/* TODO: what is the definition for aarch64? */
+#if defined(__x86_64__)
+/* TODO: find out what to do with in_protocol */
+	return 0;
+#elif defined(__i386__) || defined(__i686__)
+	return 1;
+#else /* assuming everything else is 32-bit... */
+	return 1;
+#endif
+}
+
+static int
 image_is_loadable(EFI_IMAGE_OPTIONAL_HEADER_UNION *PEHdr)
 {
 	/* If the machine type doesn't match the binary, bail, unless
 	 * we're in an allowed 64-on-32 scenario */
-	if (PEHdr->Pe32.FileHeader.Machine != machine_type) {
-		if (!(machine_type == IMAGE_FILE_MACHINE_I386 &&
-		      PEHdr->Pe32.FileHeader.Machine == IMAGE_FILE_MACHINE_X64 &&
+	if (PEHdr->Pe32.FileHeader.machine != machine_type) {
+		if (!(machine_type == GRUB_PE32_MACHINE_I386 &&
+		      PEHdr->Pe32.FileHeader.machine == GRUB_PE32_MACHINE_X86_64 &&
 		      allow_64_bit())) {
 			return 0;
 		}
 	}
 
 	/* If it's not a header type we recognize at all, bail */
-	switch (PEHdr->Pe32Plus.OptionalHeader.Magic) {
-	case EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC:
-	case EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC:
+	switch (PEHdr->Pe32Plus.OptionalHeader.magic) {
+	case GRUB_PE32_PE64_MAGIC:
+	case GRUB_PE32_PE32_MAGIC:
 		break;
 	default:
 		return 0;
@@ -417,14 +262,14 @@ image_is_loadable(EFI_IMAGE_OPTIONAL_HEADER_UNION *PEHdr)
  * Read the binary header and grab appropriate information from it
  */
 static grub_efi_status_t read_header(void *data, unsigned int datasize,
-			      PE_COFF_LOADER_IMAGE_CONTEXT *context)
+			      struct grub_shim_pe_coff_loader_image_context *context)
 {
 	EFI_IMAGE_DOS_HEADER *DosHdr = data;
 	EFI_IMAGE_OPTIONAL_HEADER_UNION *PEHdr = data;
 	unsigned long HeaderWithoutDataDir, SectionHeaderOffset, OptHeaderSize;
 
 	if (datasize < sizeof (PEHdr->Pe32)) {
-		grub_printf(L"Invalid image\n");
+		grub_printf("Invalid image\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
@@ -432,97 +277,97 @@ static grub_efi_status_t read_header(void *data, unsigned int datasize,
 		PEHdr = (EFI_IMAGE_OPTIONAL_HEADER_UNION *)((char *)data + DosHdr->e_lfanew);
 
 	if (!image_is_loadable(PEHdr)) {
-		grub_printf(L"Platform does not support this image\n");
+		grub_printf("Platform does not support this image\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
 	if (image_is_64_bit(PEHdr)) {
-		context->NumberOfRvaAndSizes = PEHdr->Pe32Plus.OptionalHeader.NumberOfRvaAndSizes;
-		context->SizeOfHeaders = PEHdr->Pe32Plus.OptionalHeader.SizeOfHeaders;
-		context->ImageSize = PEHdr->Pe32Plus.OptionalHeader.SizeOfImage;
-		OptHeaderSize = sizeof(EFI_IMAGE_OPTIONAL_HEADER64);
+		context->NumberOfRvaAndSizes = PEHdr->Pe32Plus.OptionalHeader.num_data_directories;
+		context->SizeOfHeaders = PEHdr->Pe32Plus.OptionalHeader.header_size;
+		context->ImageSize = PEHdr->Pe32Plus.OptionalHeader.image_size;
+		OptHeaderSize = sizeof(struct grub_pe64_optional_header);
 	} else {
-		context->NumberOfRvaAndSizes = PEHdr->Pe32.OptionalHeader.NumberOfRvaAndSizes;
-		context->SizeOfHeaders = PEHdr->Pe32.OptionalHeader.SizeOfHeaders;
-		context->ImageSize = (UINT64)PEHdr->Pe32.OptionalHeader.SizeOfImage;
-		OptHeaderSize = sizeof(EFI_IMAGE_OPTIONAL_HEADER32);
+		context->NumberOfRvaAndSizes = PEHdr->Pe32.OptionalHeader.num_data_directories;
+		context->SizeOfHeaders = PEHdr->Pe32.OptionalHeader.header_size;
+		context->ImageSize = (grub_efi_uint64_t)PEHdr->Pe32.OptionalHeader.header_size;
+		OptHeaderSize = sizeof(struct grub_pe32_optional_header);
 	}
 
-	context->NumberOfSections = PEHdr->Pe32.FileHeader.NumberOfSections;
+	context->NumberOfSections = PEHdr->Pe32.FileHeader.num_sections;
 
-	if (EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES < context->NumberOfRvaAndSizes) {
-		grub_printf(L"Image header too small\n");
+	if (GRUB_PE32_NUM_DATA_DIRECTORIES < context->NumberOfRvaAndSizes) {
+		grub_printf("Image header too small\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
 	HeaderWithoutDataDir = OptHeaderSize
-			- sizeof (EFI_IMAGE_DATA_DIRECTORY) * EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES;
-	if (((grub_efi_uint32_t)PEHdr->Pe32.FileHeader.SizeOfOptionalHeader - HeaderWithoutDataDir) !=
-			context->NumberOfRvaAndSizes * sizeof (EFI_IMAGE_DATA_DIRECTORY)) {
-		grub_printf(L"Image header overflows data directory\n");
+			- sizeof (struct grub_pe32_data_directory) * GRUB_PE32_NUM_DATA_DIRECTORIES;
+	if (((grub_efi_uint32_t)PEHdr->Pe32.FileHeader.optional_header_size - HeaderWithoutDataDir) !=
+			context->NumberOfRvaAndSizes * sizeof (struct grub_pe32_data_directory)) {
+		grub_printf("Image header overflows data directory\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
 	SectionHeaderOffset = DosHdr->e_lfanew
-				+ sizeof (UINT32)
-				+ sizeof (EFI_IMAGE_FILE_HEADER)
-				+ PEHdr->Pe32.FileHeader.SizeOfOptionalHeader;
-	if (((grub_efi_uint32_t)context->ImageSize - SectionHeaderOffset) / EFI_IMAGE_SIZEOF_SECTION_HEADER
+				+ sizeof (grub_efi_uint32_t)
+				+ sizeof (struct grub_pe32_coff_header)
+				+ PEHdr->Pe32.FileHeader.optional_header_size;
+	if (((grub_efi_uint32_t)context->ImageSize - SectionHeaderOffset) / sizeof (struct grub_pe32_section_table)
 			<= context->NumberOfSections) {
-		grub_printf(L"Image sections overflow image size\n");
+		grub_printf("Image sections overflow image size\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
-	if ((context->SizeOfHeaders - SectionHeaderOffset) / EFI_IMAGE_SIZEOF_SECTION_HEADER
+	if ((context->SizeOfHeaders - SectionHeaderOffset) / sizeof (struct grub_pe32_section_table)
 			< (grub_efi_uint32_t)context->NumberOfSections) {
-		grub_printf(L"Image sections overflow section headers\n");
+		grub_printf("Image sections overflow section headers\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
 	if ((((grub_efi_uint8_t *)PEHdr - (grub_efi_uint8_t *)data) + sizeof(EFI_IMAGE_OPTIONAL_HEADER_UNION)) > datasize) {
-		grub_printf(L"Invalid image\n");
+		grub_printf("Invalid image\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
 	if (PEHdr->Te.Signature != EFI_IMAGE_NT_SIGNATURE) {
-		grub_printf(L"Unsupported image type\n");
+		grub_printf("Unsupported image type\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
-	if (PEHdr->Pe32.FileHeader.Characteristics & EFI_IMAGE_FILE_RELOCS_STRIPPED) {
-		grub_printf(L"Unsupported image - Relocations have been stripped\n");
+	if (PEHdr->Pe32.FileHeader.characteristics & GRUB_PE32_RELOCS_STRIPPED) {
+		grub_printf("Unsupported image - Relocations have been stripped\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
 	context->PEHdr = PEHdr;
 
 	if (image_is_64_bit(PEHdr)) {
-		context->ImageAddress = PEHdr->Pe32Plus.OptionalHeader.ImageBase;
-		context->EntryPoint = PEHdr->Pe32Plus.OptionalHeader.AddressOfEntryPoint;
-		context->RelocDir = &PEHdr->Pe32Plus.OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC];
-		context->SecDir = &PEHdr->Pe32Plus.OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_SECURITY];
+		context->ImageAddress = PEHdr->Pe32Plus.OptionalHeader.image_base;
+		context->EntryPoint = PEHdr->Pe32Plus.OptionalHeader.entry_addr;
+		context->RelocDir = &PEHdr->Pe32Plus.OptionalHeader.base_relocation_table;
+		context->SecDir = &PEHdr->Pe32Plus.OptionalHeader.certificate_table;
 	} else {
-		context->ImageAddress = PEHdr->Pe32.OptionalHeader.ImageBase;
-		context->EntryPoint = PEHdr->Pe32.OptionalHeader.AddressOfEntryPoint;
-		context->RelocDir = &PEHdr->Pe32.OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC];
-		context->SecDir = &PEHdr->Pe32.OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_SECURITY];
+		context->ImageAddress = PEHdr->Pe32.OptionalHeader.image_base;
+		context->EntryPoint = PEHdr->Pe32.OptionalHeader.entry_addr;
+		context->RelocDir = &PEHdr->Pe32.OptionalHeader.base_relocation_table;
+		context->SecDir = &PEHdr->Pe32.OptionalHeader.certificate_table;
 	}
 
-	context->FirstSection = (EFI_IMAGE_SECTION_HEADER *)((char *)PEHdr + PEHdr->Pe32.FileHeader.SizeOfOptionalHeader + sizeof(UINT32) + sizeof(EFI_IMAGE_FILE_HEADER));
+	context->FirstSection = (struct grub_pe32_section_table *)((char *)PEHdr + PEHdr->Pe32.FileHeader.optional_header_size + sizeof(grub_efi_uint32_t) + sizeof(struct grub_pe32_coff_header));
 
 	if (context->ImageSize < context->SizeOfHeaders) {
-		grub_printf(L"Invalid image\n");
+		grub_printf("Invalid image\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
-	if ((unsigned long)((UINT8 *)context->SecDir - (UINT8 *)data) >
-	    (datasize - sizeof(EFI_IMAGE_DATA_DIRECTORY))) {
-		grub_printf(L"Invalid image\n");
+	if ((unsigned long)((grub_efi_uint8_t *)context->SecDir - (grub_efi_uint8_t *)data) >
+	    (datasize - sizeof(struct grub_pe32_data_directory))) {
+		grub_printf("Invalid image\n");
 		return GRUB_EFI_UNSUPPORTED;
 	}
 
-	if (context->SecDir->VirtualAddress >= datasize) {
-		grub_printf(L"Malformed security header\n");
+	if (context->SecDir->rva >= datasize) {
+		grub_printf("Malformed security header\n");
 		return GRUB_EFI_INVALID_PARAMETER;
 	}
 	return GRUB_EFI_SUCCESS;
@@ -781,14 +626,14 @@ grub_cmd_chainloader (grub_command_t cmd __attribute__ ((unused)),
       else {
 	grub_error (GRUB_ERR_BAD_OS, "cannot load image [%d]", status);
 
-	grub_efi_shim_lock_t *c;
-	PE_COFF_LOADER_IMAGE_CONTEXT context;
+	struct grub_shim_lock *c;
+	struct grub_shim_pe_coff_loader_image_context context;
 
         c = grub_efi_locate_protocol (&shim_protocol_guid, 0);
         grub_printf ("protocol find [0x%p]", (void *)c);
 
-        status = read_header(address,size, *context);
-        grub_printf ("read header status [%d]", status);
+        status = read_header((void *) ((grub_addr_t) address), size, &context);
+        grub_printf ("read header status [%ld]", status);
       }
 
       goto fail;
-- 
1.9.1

