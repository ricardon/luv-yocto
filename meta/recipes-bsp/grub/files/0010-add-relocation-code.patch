From ca5c53060b24dcce61a802adf023c5e8265033b7 Mon Sep 17 00:00:00 2001
From: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
Date: Fri, 20 Mar 2015 12:48:15 -0700
Subject: [PATCH 10/16] add relocation code

---
 grub-core/loader/efi/chainloader.c | 151 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 150 insertions(+), 1 deletion(-)

diff --git a/grub-core/loader/efi/chainloader.c b/grub-core/loader/efi/chainloader.c
index 74d3b63..cefb2cb 100644
--- a/grub-core/loader/efi/chainloader.c
+++ b/grub-core/loader/efi/chainloader.c
@@ -68,6 +68,25 @@ static grub_efi_char16_t *cmdline;
 
 #define EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC   5
 
+#define ALIGN_VALUE(Value, Alignment) ((Value) + (((Alignment) - (Value)) & ((Alignment) - 1)))
+#define ALIGN_POINTER(Pointer, Alignment) ((void *) (ALIGN_VALUE ((grub_efi_uintn_t)(Pointer), (Alignment))))
+
+//
+// Based relocation types.
+//
+#define EFI_IMAGE_REL_BASED_ABSOLUTE        0
+#define EFI_IMAGE_REL_BASED_HIGH            1
+#define EFI_IMAGE_REL_BASED_LOW             2
+#define EFI_IMAGE_REL_BASED_HIGHLOW         3
+#define EFI_IMAGE_REL_BASED_HIGHADJ         4
+#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR    5
+#define EFI_IMAGE_REL_BASED_ARM_MOV32A      5
+#define EFI_IMAGE_REL_BASED_ARM_MOV32T      7
+#define EFI_IMAGE_REL_BASED_IA64_IMM64      9
+#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR16  9
+#define EFI_IMAGE_REL_BASED_DIR64           10
+
+
 static const grub_efi_uint16_t machine_type =
 #if defined(__x86_64__)
 	GRUB_PE32_MACHINE_X86_64;
@@ -105,6 +124,14 @@ typedef struct {
 } EFI_IMAGE_NT_HEADERS64;
 
 ///
+/// Based relocation format.
+///
+typedef struct {
+  grub_efi_uint32_t  VirtualAddress;
+  grub_efi_uint32_t  SizeOfBlock;
+} EFI_IMAGE_BASE_RELOCATION;
+
+///
 /// Header format for TE images, defined in the PI Specification, 1.0.
 ///
 typedef struct {
@@ -273,6 +300,116 @@ static grub_efi_uint64_t image_address (grub_efi_uint64_t image, unsigned int si
 }
 
 /*
+ * Perform the actual relocation
+ */
+static grub_efi_uint64_t relocate_coff (struct grub_shim_pe_coff_loader_image_context *context,
+				 void *orig, void *data)
+{
+	EFI_IMAGE_BASE_RELOCATION *RelocBase, *RelocBaseEnd;
+	grub_efi_uint64_t Adjust;
+	grub_efi_uint16_t *Reloc, *RelocEnd;
+	char *Fixup, *FixupBase, *FixupData = NULL;
+	grub_efi_uint16_t *Fixup16;
+	grub_efi_uint32_t *Fixup32;
+	grub_efi_uint64_t *Fixup64;
+	int size = context->ImageSize;
+	void *ImageEnd = (char *)orig + size;
+
+	if (image_is_64_bit(context->PEHdr))
+		context->PEHdr->Pe32Plus.OptionalHeader.image_base = (grub_efi_uint64_t)(unsigned long)data;
+	else
+		context->PEHdr->Pe32.OptionalHeader.image_base = (grub_efi_uint32_t)(unsigned long)data;
+
+	RelocBase = (EFI_IMAGE_BASE_RELOCATION *)image_address((grub_efi_uint64_t)orig, size, context->RelocDir->rva);
+	RelocBaseEnd = (EFI_IMAGE_BASE_RELOCATION *)image_address((grub_efi_uint64_t)orig, size, context->RelocDir->rva + context->RelocDir->size - 1);
+
+	if (!RelocBase || !RelocBaseEnd) {
+		grub_printf("Reloc table overflows binary\n");
+		return GRUB_EFI_UNSUPPORTED;
+	}
+
+	Adjust = (grub_efi_uintn_t)data - context->ImageAddress;
+
+	if (Adjust == 0)
+		return GRUB_EFI_SUCCESS;
+
+	while (RelocBase < RelocBaseEnd) {
+		Reloc = (grub_efi_uint16_t *) ((char *) RelocBase + sizeof (EFI_IMAGE_BASE_RELOCATION));
+
+		if ((RelocBase->SizeOfBlock == 0) || (RelocBase->SizeOfBlock > context->RelocDir->size)) {
+			grub_printf("Reloc block size %d is invalid\n", RelocBase->SizeOfBlock);
+			return GRUB_EFI_UNSUPPORTED;
+		}
+
+		RelocEnd = (grub_efi_uint16_t *) ((char *) RelocBase + RelocBase->SizeOfBlock);
+		if ((void *)RelocEnd < orig || (void *)RelocEnd > ImageEnd) {
+			grub_printf("Reloc entry overflows binary\n");
+			return GRUB_EFI_UNSUPPORTED;
+		}
+
+		FixupBase = (char *)image_address((grub_efi_uint64_t)data, size, RelocBase->VirtualAddress);
+		if (!FixupBase) {
+			grub_printf("Invalid fixupbase\n");
+			return GRUB_EFI_UNSUPPORTED;
+		}
+
+		while (Reloc < RelocEnd) {
+			Fixup = FixupBase + (*Reloc & 0xFFF);
+			switch ((*Reloc) >> 12) {
+			case EFI_IMAGE_REL_BASED_ABSOLUTE:
+				break;
+
+			case EFI_IMAGE_REL_BASED_HIGH:
+				Fixup16   = (grub_efi_uint16_t *) Fixup;
+				*Fixup16 = (grub_efi_uint16_t) (*Fixup16 + ((grub_efi_uint16_t) ((grub_efi_uint32_t) Adjust >> 16)));
+				if (FixupData != NULL) {
+					*(grub_efi_uint16_t *) FixupData = *Fixup16;
+					FixupData             = FixupData + sizeof (grub_efi_uint16_t);
+				}
+				break;
+
+			case EFI_IMAGE_REL_BASED_LOW:
+				Fixup16   = (grub_efi_uint16_t *) Fixup;
+				*Fixup16  = (grub_efi_uint16_t) (*Fixup16 + (grub_efi_uint16_t) Adjust);
+				if (FixupData != NULL) {
+					*(grub_efi_uint16_t *) FixupData = *Fixup16;
+					FixupData             = FixupData + sizeof (grub_efi_uint16_t);
+				}
+				break;
+
+			case EFI_IMAGE_REL_BASED_HIGHLOW:
+				Fixup32   = (grub_efi_uint32_t *) Fixup;
+				*Fixup32  = *Fixup32 + (grub_efi_uint32_t) Adjust;
+				if (FixupData != NULL) {
+					FixupData             = ALIGN_POINTER (FixupData, sizeof (grub_efi_uint32_t));
+					*(grub_efi_uint32_t *)FixupData  = *Fixup32;
+					FixupData             = FixupData + sizeof (grub_efi_uint32_t);
+				}
+				break;
+
+			case EFI_IMAGE_REL_BASED_DIR64:
+				Fixup64 = (grub_efi_uint64_t *) Fixup;
+				*Fixup64 = *Fixup64 + (grub_efi_uint64_t) Adjust;
+				if (FixupData != NULL) {
+					FixupData = ALIGN_POINTER (FixupData, sizeof(grub_efi_uint64_t));
+					*(grub_efi_uint64_t *)(FixupData) = *Fixup64;
+					FixupData = FixupData + sizeof(grub_efi_uint64_t);
+				}
+				break;
+
+			default:
+				grub_printf("Unknown relocation\n");
+				return GRUB_EFI_UNSUPPORTED;
+			}
+			Reloc += 1;
+		}
+		RelocBase = (EFI_IMAGE_BASE_RELOCATION *) RelocEnd;
+	}
+
+	return GRUB_EFI_SUCCESS;
+}
+
+/*
  * Read the binary header and grab appropriate information from it
  */
 static grub_efi_status_t read_header(void *data, unsigned int datasize,
@@ -731,7 +868,19 @@ grub_cmd_chainloader (grub_command_t cmd __attribute__ ((unused)),
 		goto fail;
 	}
 
-	grub_printf("I made it here!\n");
+	if (context.RelocDir->size) {
+		status = relocate_coff(&context,
+				       (void *) ((grub_addr_t) address),
+				       (void *) ((grub_addr_t) buffer));
+		if (status != GRUB_EFI_SUCCESS) {
+			grub_printf("Relocation failed: [%ld]\n", status);
+			// Free pages(buffer)
+			goto fail;
+		}
+		grub_printf("Relocation success: [%ld]\n", status);
+	}
+
+	grub_printf("I made it here!!\n");
 	grub_error (GRUB_ERR_BAD_OS, "cannot load image [%d]", status);
       }
 
-- 
1.9.1

